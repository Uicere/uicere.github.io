<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Live For Code</title>
  
  
  <link href="https://uicere.github.io/atom.xml" rel="self"/>
  
  <link href="https://uicere.github.io/"/>
  <updated>2023-09-04T13:51:32.180Z</updated>
  <id>https://uicere.github.io/</id>
  
  <author>
    <name>Live For Code</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>状态压缩练习</title>
    <link href="https://uicere.github.io/article/13/"/>
    <id>https://uicere.github.io/article/13/</id>
    <published>2023-09-04T10:00:00.000Z</published>
    <updated>2023-09-04T13:51:32.180Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://www.luogu.com.cn/problem/P2704">P2704 [NOI2001] 炮兵阵地</a></h1><p>考虑好在哪里放比较好。</p><ul><li>行判断</li><li>列判断</li><li>答案统计</li></ul><p>当前状态只与上两行有关系，因此压两行，考虑上一行状态。</p><p><strong>有一个滚动数组优化技巧,如果留 $n$ 位，$f_{i \mod n}$，从 $0$ 开始计数。</strong></p><p>$$<br>f_{L,S,i}=\max(f_{L,S,i},f_{FL,L,i-1}+sum_S);<br>$$</p><p>设山丘表示为 $1$，平原为 $0$，与为 $0$ 表示合法，因为有山丘当着不怕。</p><p>只考虑以当前点的整个上面。</p><p><strong>每次皆以合法转移，绝对行</strong>。</p><p><strong>总结：关键再判断不合法状态</strong></p><h1><a href="https://www.luogu.com.cn/problem/P3092">P3092 [USACO13NOV] No Change G</a></h1><p>二分+状压。</p><p>只与硬币的放置状态有关，那我们考虑状态之间的转移。</p><p>对于某个状态从他的子集转移，子集一定是满足条件的，因为从小到大，必然是可以转移的。</p><p>$dp_i$ 当前存储的最优状态下，可以到达的最右状态。</p><p>$f_i$ 当前状态下通过确定顺序能购买的花费硬币总代价。</p><p>顺序是通过子集最优继承的。</p><p><strong>问题本质还是最优决策，决策量很小，那肯定是考虑状态枚举</strong>。</p><p><strong>对于每个状态我们保留了最优决策后的最大贡献</strong>。</p><h1><a href="https://www.luogu.com.cn/problem/P3694">P3694 邦邦的大合唱站队</a></h1><p>决策状态的转移，就是这么妙，考虑最终状态的所有可能性我们只有 $2^m$ 种状态因此不管了状压稳过。</p><p>还是每次都是小集合对大集合的贡献。</p><p><strong>考虑决策量的数量印象我们最后的答案</strong>。</p>]]></content>
    
    
    <summary type="html">状态压缩练习</summary>
    
    
    
    <category term="状态压缩" scheme="https://uicere.github.io/category/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    
    <category term="动态规划" scheme="https://uicere.github.io/tag/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>p5024</title>
    <link href="https://uicere.github.io/article/279599637/"/>
    <id>https://uicere.github.io/article/279599637/</id>
    <published>2023-08-31T02:51:44.000Z</published>
    <updated>2023-09-04T07:37:14.778Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ejh9o1ro.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 200010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hd[maxn],nxt[maxm],pnt[maxm],tot=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> fa[maxn][<span class="number">20</span>],val[maxn],dep[maxn],n,q;</span><br><span class="line">ll f[maxn][<span class="number">2</span>],g[maxn][<span class="number">2</span>],fh[maxn][<span class="number">20</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1LL</span>&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="type">char</span> Type[<span class="number">10</span>];</span><br><span class="line">set&lt;pii&gt; st;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch=x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    pnt[++tot]=y,nxt[tot]=hd[x],hd[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> FA,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    fa[x][<span class="number">0</span>]=FA,dep[x]=d;</span><br><span class="line">    f[x][<span class="number">1</span>]=val[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=hd[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="type">int</span> v=pnt[i];</span><br><span class="line">        <span class="keyword">if</span>(v==FA)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,x,d+<span class="number">1</span>);</span><br><span class="line">        f[x][<span class="number">0</span>]+=f[v][<span class="number">1</span>],f[x][<span class="number">1</span>]+=<span class="built_in">min</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=hd[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="type">int</span> v=pnt[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa[x][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        g[v][<span class="number">0</span>]=g[x][<span class="number">1</span>]+f[x][<span class="number">1</span>]-<span class="built_in">min</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">        g[v][<span class="number">1</span>]=<span class="built_in">min</span>(g[x][<span class="number">0</span>]+f[x][<span class="number">0</span>]-f[v][<span class="number">1</span>],g[v][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">dfs_2</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> a,<span class="type">int</span> y,<span class="type">int</span> b)</span></span>&#123;<span class="comment">// x 和 a 互换 , y 和 b 互换</span></span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y])</span><br><span class="line">        <span class="built_in">swap</span>(x,y),<span class="built_in">swap</span>(a,b);</span><br><span class="line">    ll tx[<span class="number">2</span>]=&#123;INF,INF&#125;,ty[<span class="number">2</span>]=&#123;INF,INF&#125;;</span><br><span class="line">    ll nx[<span class="number">2</span>],ny[<span class="number">2</span>];</span><br><span class="line">    tx[a]=f[x][a],ty[b]=f[y][b];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;~i;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[fa[x][i]]&gt;=dep[y])&#123;</span><br><span class="line">            nx[<span class="number">0</span>]=nx[<span class="number">1</span>]=INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">                    nx[j]=<span class="built_in">min</span>(nx[j],tx[k]+fh[x][i][k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            tx[<span class="number">0</span>]=nx[<span class="number">0</span>],tx[<span class="number">1</span>]=nx[<span class="number">1</span>],x=fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)</span><br><span class="line">        <span class="keyword">return</span> tx[b]+g[x][b];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;~i;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])&#123;</span><br><span class="line">            nx[<span class="number">0</span>]=nx[<span class="number">1</span>]=ny[<span class="number">0</span>]=ny[<span class="number">1</span>]=INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">                    nx[j]=<span class="built_in">min</span>(nx[j],tx[k]+fh[x][i][k][j]);</span><br><span class="line">                    ny[j]=<span class="built_in">min</span>(ny[j],ty[k]+fh[y][i][k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tx[<span class="number">0</span>]=nx[<span class="number">0</span>],tx[<span class="number">1</span>]=nx[<span class="number">1</span>],x=fa[x][i];</span><br><span class="line">            ty[<span class="number">0</span>]=ny[<span class="number">0</span>],ty[<span class="number">1</span>]=ny[<span class="number">1</span>],y=fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lca=fa[x][<span class="number">0</span>];</span><br><span class="line">    ll ans0=f[lca][<span class="number">0</span>]-f[x][<span class="number">1</span>]-f[y][<span class="number">1</span>]+tx[<span class="number">1</span>]+ty[<span class="number">1</span>]+g[lca][<span class="number">0</span>];</span><br><span class="line">    ll ans1=f[lca][<span class="number">1</span>]-<span class="built_in">min</span>(f[x][<span class="number">0</span>],f[x][<span class="number">1</span>])-<span class="built_in">min</span>(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>])+<span class="built_in">min</span>(tx[<span class="number">0</span>],tx[<span class="number">1</span>])+<span class="built_in">min</span>(ty[<span class="number">0</span>],ty[<span class="number">1</span>])+g[lca][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(ans0,ans1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(q),<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,Type);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(val[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u),<span class="built_in">read</span>(v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">        st.<span class="built_in">insert</span>(<span class="built_in">mp</span>(u,v)),st.<span class="built_in">insert</span>(<span class="built_in">mp</span>(v,u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>),<span class="built_in">dfs_2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fh[i][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=INF;</span><br><span class="line">        fh[i][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=f[fa[i][<span class="number">0</span>]][<span class="number">1</span>]-<span class="built_in">min</span>(f[i][<span class="number">0</span>],f[i][<span class="number">1</span>]);</span><br><span class="line">        fh[i][<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=f[fa[i][<span class="number">0</span>]][<span class="number">0</span>]-f[i][<span class="number">1</span>];</span><br><span class="line">        fh[i][<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=f[fa[i][<span class="number">0</span>]][<span class="number">1</span>]-<span class="built_in">min</span>(f[i][<span class="number">0</span>],f[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">19</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp=fa[i][j<span class="number">-1</span>];</span><br><span class="line">            fa[i][j]=fa[tmp][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;<span class="number">2</span>;u++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;<span class="number">2</span>;v++)&#123;</span><br><span class="line">                    fh[i][j][u][v]=INF;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">0</span>;w&lt;<span class="number">2</span>;w++)</span><br><span class="line">                        fh[i][j][u][v]=<span class="built_in">min</span>(fh[i][j][u][v],fh[i][j<span class="number">-1</span>][u][w]+fh[tmp][j<span class="number">-1</span>][w][v]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b,x,y;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a),<span class="built_in">read</span>(x),<span class="built_in">read</span>(b),<span class="built_in">read</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(!x&amp;&amp;!y&amp;&amp;st.<span class="built_in">find</span>(<span class="built_in">mp</span>(a,b))!=st.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(a,x,b,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Lucas 定理证明</h1><p>对于素数 $p$ 意义正整数 $m&gt;n$ 在 $p$ 进制下又表示。<br>$$<br>m=a_0+a_1p+\dots +a_k\times p^k<br>$$<br>$$<br>n=a_0+a_1p+\dots +a_k\times p^k<br>$$<br>那么</p><p>$$\binom{n}{m}\equiv\prod_{i=0}^k\binom{a_i}{b_i}\pmod p$$</p><p><strong>引理1</strong>：</p><p>$p$ 为素数， $1\le k \le p-1$</p><p>$p\mid \binom{k}{p}$</p><p>未完待续$\dotsb$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/image_hosting/ejh9o1ro.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>组合数学练习</title>
    <link href="https://uicere.github.io/article/11/"/>
    <id>https://uicere.github.io/article/11/</id>
    <published>2023-08-30T16:00:00.000Z</published>
    <updated>2023-09-04T07:37:06.298Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/training/369766#problems">Open it quickly</a></p><h1><a href="https://www.luogu.com.cn/problem/P1350">车的放置</a></h1><p>有两个限制条件，考虑转化成一个，因此固定一个顺序，这就用转化的方法消除了一个限制。</p><p>因此我们算就好。</p><p>不归则变成规则，因此分成 $a\times(b+d),c\times d$。</p><p>因为有地方重复计算减去就好。</p><p>车有编号，因此乘上顺序即可。</p><p>$$<br>ans=\sum_{i=0}^k\binom{a}{i}\binom{b+d-(k-i)}{i}i!<br>\binom{c}{k-i}\binom{d}{k-i}(k-i)!<br>$$</p><h1><a href="https://www.luogu.com.cn/problem/P1771">方程的解</a></h1><p>$g(x)$ 为固定的数，问题简单可以转化成模型。</p><p>$x_1+x_2+x_3+x_4+x_n=k$ 的正整数解的组数。</p><p>因此答案为：</p><p>$${g(x)-1 \choose n-1}$$</p><p>因为没有取模得用<strong>高精度</strong>。</p><p>但是 $\dotsb$，略。</p><h1><a href="https://www.luogu.com.cn/problem/P3166">[CQOI2014] 数三角形</a></h1><p>首先给的是行列数，而我们求的是点上数量，因此先都 $+1$。</p><p>先不考虑不在一条直线上的，答案为 $\binom{n*m}{3}$</p><p>在考虑在一条线上的。</p><p>有如下三种情况：</p><ul><li>同一行</li><li>同一列</li><li>同一对角线，双对角线是对称的 $\times 2$ 即可。</li></ul><p>前两个好求分别是 $n\times \binom{m}{3},m\times \binom{n}{3}$。</p><p>第三个我们先考虑固定一个原点，在枚举一个点，两点确定一条直线，看这条直线上有多少个，然后剩下的如果不是在远点，那就是平移，运用乘法原理即可解决。</p><p>现在考虑对于同一直线的点的个数，首先我们固定的是 $(0,0),(i,j)$，那么 $y=\frac{i}{j}x，0&lt;x\le i$，我们考虑枚举分母的倍数，前提是约分完毕，即$y=\frac{\frac{i}{\gcd(i,j)}}{\frac{j}{\gcd(i,j)}}x，0&lt;x\le i$，那么定义域上满足在整点的个数为 $\frac{i}{\frac{j}{\gcd(i,j)}}$ 即 $\gcd(i,j)$，减去本身剩下任选即 $\gcd(i,j)-1$，平移有 $(n-i)\times(m-j)$ 种情况，因此我们对于每个点要减去的就是 $(n-i)\times(m-j)\times (\gcd(i,j)-1)$。</p><p><strong>不过有个神奇的推式子法，$O(n)$ 做，是莫反。</strong></p><p><a href="https://www.luogu.com.cn/blog/emptyset/solution-p3166">链接</a></p><h1><a href="https://www.luogu.com.cn/problem/P4345">[SHOI2015] 超能粒子炮·改</a></h1><p>求<br>$$<br>\sum_{i=0}^k\binom{n}{i}\pmod{2333}<br>$$</p><p>$10^5$ 次询问，$n,k\le 10^{18}$，$2333$ <strong>是素数</strong>。</p><p>跟据 $Lucas$ 定理。</p><p>$$\binom{n}{m}\mod p=\binom{\frac{n}{p}}{\frac{m}{p}}\times \binom{n\mod p}{m \mod p}$$</p><p>设 $f_{n,k}=\sum_{i=0}^k\binom{n}{i}$。</p><p>$$<br>f_{n,k}= \sum_{i=0}^k\binom{n}{i} \<br>=\sum_{i=0}^k\binom{\frac{n}{p}}{\frac{i}{p}}\times \binom{n\mod p}{i \mod p}<br>$$</p><p>因此我们可以发现这就是一个类似于整除分块的东西。</p><p>$$<br>\binom{\frac{n}{p}}{0}\sum_{i=0}^{p-1}\binom{n \mod p}{i}+\dotsb+\binom{\frac{n}{p}}{\frac{k}{p}}\sum_{i=0}^{k\mod p}\binom{n \mod p}{i}<br>$$</p><p>显然后面形式完整，先略去最后一项。</p><p>即<br>$$<br>\sum_{i=0}^{p-1}\binom{n \mod p}{i}\sum_{j=0}^{\frac{k}{p}-1}\binom{\frac{n}{p}}{j}<br>$$</p><p>代入 $f$ 即 $f_{n \mod p,p-1}\times f_{\frac{n}{p},\frac{k}{p}-1}$</p><p>在加上最后一项，完毕。<br>$$<br>ans=f_{n \mod p,p-1}\times f_{\frac{n}{p},\frac{k}{p}-1}+\binom{\frac{n}{p}}{\frac{k}{p}}f_{n\mod  p,k \mod p}<br>$$</p><p>显然可以预处理 $[0,p-1]$ 范围内的所有需要的。</p><p>$O(p^2+T\log_{2333}^2 n)$</p><h1><a href="https://www.luogu.com.cn/problem/P1641"> [SCOI2010] 生成字符串</a></h1><p>转化为<strong>非降路径计数问题模型</strong>,即可解决。</p><p>$\color{red}{切记(C(n+m,m)-C(n+m,m-1)+p)\mod p要先加在模，毕竟是模意义下}$</p><h1><a href="https://www.luogu.com.cn/problem/CF1204E">Natasha, Sasha and the Prefix Sums</a></h1><p>这题跟上面得一样，只不过需要一步转化。</p><p>设 $f_i$ 表示为最大前缀和等于 $i$ 的序列数量，显然答案为 $\sum_{i=1}^ni\times f_i$，但不好求就容斥。</p><p>设 $g_i$ 表示为最大前缀和<strong>大于等于</strong> $i$ 的序列数量，这个好求。</p><p>那么 $f_i$ 就是差分一下，$f_i=g_{i-1}-g_i$。</p><p>求 $g_i$ 有两种情况。</p><p>$$<br>g_i=\binom{n+m}{n}i\le n-m\<br>g_i=\binom{n+m}{n-i},i\ge n-m<br>$$</p><p>其实就是求得与 $y=i$ 交的路径数量，这是好求的。</p><p><strong>这题与上题的区别就是那题是时时刻刻满足 $n \le m$，而这题则是有出现过一次就好</strong>。</p><p><strong>剩下的具体图</strong>，<strong>我太懒了</strong>，<strong>先放一放</strong>。</p><h1><a href="https://www.luogu.com.cn/problem/P3200">[HNOI2009] 有趣的数列</a></h1><p>非降序列，那我们求考虑固定顺序。</p><p>结论：任意时刻偶数位个数要满足 $\le$ 奇数位个数。</p><p>此题同上题，将问题转化后成为卡特兰数模板题。</p><p><strong>还有就是模数可能不是质数，我们需要我们转化位整数分解形式约分求解</strong>。</p><p><strong>因为众所周知费马小定理求逆元适用于模数为素数，扩展欧几里得适用于 $\gcd(a,p)=1$</strong>。</p><p>除分解质因数还可以通过求 $1-n$ 阶乘种素数个数来求解。</p><p>例如，对于素数 $p$，$1-n$ 中有 $\frac{n}{p}+\frac{n}{p^2}+\frac{n}{p^k},0&lt; k &lt;\log_pn$。</p><h1><a href="https://www.luogu.com.cn/problem/P3270">[JLOI2016] 成绩比较</a></h1><p>这题绝对是好题，<strong>是道基础容斥题</strong>。</p><p>前置<a href="https://uicere.github.io/article/12">拉格朗日差值</a>。</p><p>求恰好被碾压的人数为 $k$ 显然不好求。</p><p>那么考虑容斥。</p><p>钦定 $f_i$ 为恰好有 $i$ 个人被碾压。</p><p>设 $g_i$ 为至少有 $i$ 个人被碾压。</p><p>$g$ 好求，钦定有 $i$ 个人被撵压，然后对于每一科在剩下的 $n-1-i$ 个人中选出没有被 $D$ 神碾压但是这一科比他低的 $n-r_i-i$ 个人，然后枚举 $D$ 神分数，并计算所有人可选的分数的情况的方案数。<br>即</p><p>$$<br>g_i=\binom{n-1}{i}\prod_{j=1}^m\Bigg(\binom{n-1-i}{n-r_j-i}\sum_{k=1}^{u_j}k^{n-r_j}(u_j-k)^{r_j-1}\Bigg)<br>$$<br>但是由于 $u$ 太大，我们考虑求和变幻。<br>$$<br>\begin{aligned}<br>S&amp;=\sum_{k=1}^{u_i}k^{n-r_j}(u_j-k)^{r_j-1}\<br>&amp;=\sum_{k=1}^{u_i}k^{n-r_j}\sum_{l=0}^{r_j-1}\binom{r_j-1}{l}u_j^{r_j-1-l}(-k)^l\<br>&amp;=\sum_{l=0}^{r_j-1}\binom{r_j-1}{l}u_j^{r_j-1-l}(-1)^l\sum_{k=1}^{u_i}k^{n-r_j+l}<br>\end{aligned}<br>$$<br>$$<br>\sum_{k=1}^{u_i}k^{n-r_j+l}<br>$$<br>该式是一个 $n-r_j+l+1$ 次多项式，可以使用拉格朗日差值 $O(n)$ 求解。</p><p>具体证明看上方链接。</p><p>那么答案为 $f_k=\sum_{i=k}^{n-1}(-1)^{i-k}\binom{i}{k}g_i$。</p><p>复杂度 $O(nm^2)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">108</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> fac[N+<span class="number">1</span>],inv[N+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> pre[N],suf[N];</span><br><span class="line"><span class="type">int</span> n,m,K;</span><br><span class="line"><span class="type">int</span> u[N],r[N];</span><br><span class="line"><span class="type">int</span> f,g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=<span class="number">1ll</span>*res*a%mod;</span><br><span class="line">        a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>]=fac[<span class="number">1</span>]=inv[<span class="number">0</span>]=fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[n]=<span class="built_in">qmi</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        inv[i]=<span class="number">1ll</span>*inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    suf[k+<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        pre[i]=<span class="number">1ll</span>*pre[i<span class="number">-1</span>]*(n-i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k+<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        suf[i]=<span class="number">1ll</span>*suf[i+<span class="number">1</span>]*(n-i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        y=(y+<span class="built_in">qmi</span>(i,k))%mod;</span><br><span class="line">        <span class="type">int</span> res1=<span class="number">1ll</span>*pre[i<span class="number">-1</span>]*suf[i+<span class="number">1</span>]%mod;</span><br><span class="line">        <span class="type">int</span> res2=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*fac[k+<span class="number">2</span>-i]%mod*(((k+<span class="number">2</span>-i)&amp;<span class="number">1</span>)?<span class="number">-1</span>:<span class="number">1</span>)%mod;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*y*res1%mod*<span class="built_in">qmi</span>(res2,mod<span class="number">-2</span>)%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lagrange[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;u[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>(n+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=r[j]<span class="number">-1</span>;l++)&#123;</span><br><span class="line">            lagrange[j][l]=<span class="built_in">calc</span>(u[j],n-r[j]+l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> res1=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> res2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=r[j]<span class="number">-1</span>;l++)&#123;</span><br><span class="line">                res2=(res2+<span class="number">1ll</span>*<span class="built_in">C</span>(r[j]<span class="number">-1</span>,l)*<span class="built_in">qmi</span>(u[j],r[j]<span class="number">-1</span>-l)%mod*((l&amp;<span class="number">1</span>)?<span class="number">-1</span>:<span class="number">1</span>)%mod*lagrange[j][l]%mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            res2=<span class="number">1ll</span>*res2*<span class="built_in">C</span>(n<span class="number">-1</span>-i,n-r[j]-i)%mod;</span><br><span class="line">            res1=<span class="number">1ll</span>*res2*res1%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=<span class="number">1ll</span>*<span class="built_in">C</span>(n<span class="number">-1</span>,i)*res1%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        f=(f+<span class="number">1ll</span>*(((i-K)&amp;<span class="number">1</span>)?<span class="number">-1</span>:<span class="number">1</span>)*<span class="built_in">C</span>(i,K)%mod*g[i]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(f+mod)%mod&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于球相同，盒不同，考虑不定方程计数模型，仅关心每个盒子分配的个体数量。</strong></p><p><strong>问题分解是分步还是分类</strong></p><p><strong>分步处理，要考虑选取顺序问题</strong></p><p><strong>在计数问题，特别区分选取是否有序</strong></p><h1>一下是一些简单题。</h1><h2 id="m1-n0-m-le-n-，每个-1-后面至少有-1-个-0-方案数。">$m1,n0 ,m\le n$，每个 $1$ 后面至少有 $1$ 个 $0$ 方案数。</h2><ul><li><p>先放 $n$ 个 $0$ 只有一种方法，然后在 $0$ 之间 $n$ 个位置（除末尾）随便放 $m$ 个 $1$，$ans=\binom{n}{m}$。</p></li><li><p>$10$ 看成整体 ，看成 $m$ 个隔板，$m+1$ 空，相当于</p></li></ul><p>$$<br>x_1+x_2+\dots +x_m+1=n-m<br>$$<br>求解非负整数解个数 $\binom{n-m+m+1-1}{n-m}$。</p><h2 id="3-蓝球，-2-红球，-2-黄球，满足黄球不相邻的方案数。">$3$ 蓝球，$2$ 红球，$2$ 黄球，满足黄球不相邻的方案数。</h2><p>解：</p><p>令 $S={3b,2r,2y}$ ，该方案数为 $\frac{7!}{3!2!2!}$。</p><p>这是不考虑相不相邻，若相邻就是把两个黄球看成一个整体 $S={3b,2r,1y}$，该方案数为 $\frac{6!}{3!2!}$。</p><p>相减就是答案。</p><h2 id="S-1a-1-1a-2-dots-infty-a-t-1-dots-infty-a-k-，求其的-r-组合数。">$S={1a_1,1a_2,\dots, \infty a_{t+1},\dots,\infty a_{k} }$，求其的 $r$ 组合数。</h2><p>分成两集合处理。<br>$$<br>\sum_{i=0}^r\binom{t}{i}\binom{k-t+r-i-1}{r-i}<br>$$</p><h2 id="S-infty-0-infty-1-infty-2-种取-n-个数，不允许相邻的两位置相同，问排列数？">$S={\infty 0,\infty 1,\infty 2 }$ 种取 $n$ 个数，不允许相邻的两位置相同，问排列数？</h2><p>固定住一个位置，剩下唯一。</p><p>$3\times 2^{n-1}$</p><h1>容斥</h1><h2 id="多重集的组合数">多重集的组合数</h2><p>考虑这个问题：设 $S={n_1\cdot a_1,n_2\cdot a_2,\cdots,n_k\cdot a_k,}$ 表示由 $n_1$ 个 $a_1$，$n_2$ 个 $a_2$，…，$n_k$ 个 $a_k$ 组成的多重集。那么对于正整数 $r$，从 $S$ 中选择 $r$ 个元素组成一个多重集的方案数。</p><p>这样就限制了每种元素的取的个数。同样的，我们可以把这个问题转化为带限制的线性方程求解：</p><p>$$<br>\forall i\in [1,k],\ x_i\le n_i,\ \sum_{i=1}^kx_i=r<br>$$</p><p>于是很自然地想到了容斥原理。容斥的模型如下：</p><ol><li>全集：$\displaystyle \sum_{i=1}^kx_i=r$ 的非负整数解。</li><li>属性：$x_i\le n_i$。</li></ol><p>于是设满足属性 $i$ 的集合是 $S_i$，$\overline{S_i}$ 表示不满足属性 $i$ 的集合，即满足 $x_i\ge n_i+1$ 的集合（转化为上面插板法的问题三）。那么答案即为</p><p>$$<br>\left|\bigcap_{i=1}^kS_i\right|=|U|-\left|\bigcup_{i=1}^k\overline{S_i}\right|<br>$$</p><p>根据容斥原理，有：</p><p>$$<br>\begin{aligned}<br>\left|\bigcup_{i=1}^k\overline{S_i}\right|<br>=&amp;\sum_i\left|\overline{S_i}\right|<br>-\sum_{i,j}\left|\overline{S_i}\cap\overline{S_j}\right|<br>+\sum_{i,j,k}\left|\overline{S_i}\cap\overline{S_j}\cap\overline{S_k}\right|<br>-\cdots\<br>&amp;+(-1)^{k-1}\left|\bigcap_{i=1}^k\overline{S_i}\right|\<br>=&amp;\sum_i\binom{k+r-n_i-2}{k-1}<br>-\sum_{i,j}\binom{k+r-n_i-n_j-3}{k-1}+\sum_{i,j,k}\binom{k+r-n_i-n_j-n_k-4}{k-1}<br>-\cdots\<br>&amp;+(-1)^{k-1}\binom{k+r-\sum_{i=1}^kn_i-k-1}{k-1}<br>\end{aligned}<br>$$</p><p>拿全集 $\displaystyle |U|=\binom{k+r-1}{k-1}$ 减去上式，得到多重集的组合数</p><p>$$<br>Ans=\sum_{p=0}^k(-1)^p\sum_{A}\binom{k+r-1-\sum_{A} n_{A_i}-p}{k-1}<br>$$</p><p>其中 A 是充当枚举子集的作用，满足 $|A|=p,\ A_i&lt;A_{i+1}$。</p><h2 id="Devu-and-Flowers"><a href="https://www.luogu.com.cn/problem/CF451E">Devu and Flowers</a></h2><p>至于像这种容斥我们就应该考虑集合的所有子集去统计答案。</p>]]></content>
    
    
    <summary type="html">组合数学练习</summary>
    
    
    
    <category term="组合数学" scheme="https://uicere.github.io/category/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="https://uicere.github.io/tag/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>拉格朗日差值</title>
    <link href="https://uicere.github.io/article/12/"/>
    <id>https://uicere.github.io/article/12/</id>
    <published>2023-08-30T16:00:00.000Z</published>
    <updated>2023-09-02T11:10:23.859Z</updated>
    
    <content type="html"><![CDATA[<h1>差分的定义</h1><p>定义 $f(x)4$ 的差分（向后差） $\nabla f(x)$ ：</p><p>$\nabla f(x)=f(x)-f(x-1)$</p><p>则有：</p><p>$$\begin{aligned} \nabla^{2}f(x) &amp;=\nabla(\nabla f(x)) \ \ &amp;=\nabla ( f(x)-f(x-1) ) \\&amp;=f(x)-f(x-1)-[f(x-1)-f(x-2)] \\&amp;=f(x)-2f(x-1)+f(x-2) \end{aligned}\<br>\dots<br>$$</p><p>等等，因此称 $\nabla^{n}f(x)$ 为 $f(x)$ 的 $n$ 阶差分,</p><p>并且 $\nabla^{0}f(x)=f(x)$。</p><p>差分与级数部分和的联系<br>首先有个比较明显的关系：</p><p>$\nabla^{n+1}f(x)= \nabla^{n}f(x)- \nabla^{n}f(x-1)$</p><p>再结合级数部分和的公式:</p><p>$f(x)=\sum_{a=1}^{x}[f(a)-f(a-1)]+f(0)$</p><p>就得到:</p><p>$\begin{aligned} \nabla^{n}f(x)&amp;=\sum_{a=1}^{x}[\nabla^{n}f(a)-\nabla^{n}f(a-1)] +\nabla^{n}f(0) \&amp;=\sum_{a=1}^{x}\nabla^{n+1}f(a) +\nabla^{n}f(0) \end{aligned}$</p><p>用上面的式子不断递归，并记 $c_{n}=\nabla^{n}f(0)$：</p><p>$\begin{aligned}\nabla^{n}f(x)&amp;=[\sum_{a=1}^{x}\nabla^{n+1}f(a)]+c_{n} \&amp;=[\sum_{a=1}^{x}[\sum_{b=1}^{a}\nabla^{n+2}f(b)] +c_{n+1}] +c_{n} \&amp;=[\sum_{a=1}^{x}[\sum_{b=1}^{a}[\sum_{c=1}^{b}[\sum_{d=1}^{c}\nabla^{n+4}f(d)] +c_{n+3}] +c_{n+2}] +c_{n+1}] +c_{n} \\&amp;······ \end{aligned}$</p><p>然后我们总结下上面发生的关系，并且把后面的常数尾巴提炼出来，写成多项式 ：</p><p>$\nabla^{n}f(x)=[\underbrace{\sum_{a=1}^{x}\sum_{b=1}^{a}\sum_{c=1}^{b}···\sum_{q=1}^{m}}_\text{s个 } \nabla^{n+s}f(q)]+c(x)$</p><p>令 $n=-s$ ： $\begin{aligned}\nabla^{-s}f(x)&amp;=[\underbrace{\sum_{a=1}^{x}\sum_{b=1}^{a}\sum_{c=1}^{b}···\sum_{q=1}^{m}}<em>\text{s个 }\nabla^{0}f(q)]+c(x) \&amp;=[\underbrace{\sum</em>{a=1}^{x}\sum_{b=1}^{a}\sum_{c=1}^{b}···\sum_{q=1}^{m}}_\text{s个 }f(q)]+c(x) \end{aligned}$</p><p>可以看出负数阶差分相当于正数阶求和，求和是差分的逆运算。</p><h1>多项式证明</h1><p>对一个数列 ${a_n}$，把元素两两做差，得到数列 ${b_n}$ ，那么 ${b_n}$ 就是 ${a_n}$的<strong>阶差数列</strong>，记数列 ${b_n}$ 为数列 ${a_n}$ 的一阶差分，记作 $\nabla{f(x)}=f(x)-f(x-1)$。</p><p>同理高阶同上，即 $\nabla^p{f(x)}=\nabla(\nabla^{p-1}f(x))$。</p><p><strong>注</strong>：差分之后元素个数是会依次减少的。</p><p><strong>$p$ 阶等差数列定义</strong>：若 ${a_n}$ 的 $p$ 阶差分为非 $0$ 常数数列，那么称它为它的 $p$ 阶等差数列。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1ma2g48m.png" alt=""></p><p>可以证明 $S(n)=\sum_{i=1}^ni^k$，其中 $k$ 为常数，为多项式。</p><hr><blockquote><p>以下借助 $oi-wiki$</p></blockquote><h1>差分法</h1><p>差分法适用于 $x_i=i$ 的情况。</p><p>如，用差分法求某三次多项式 $f(x)=\sum_{i=0}^{3} a_ix^i$ 的多项式形式，已知 $f(1)$ 至 $f(6)$ 的值分别为 $1, 5, 14, 30, 55, 91$。</p><p>$$<br>\begin{array}{cccccccccccc}<br>1 &amp;    &amp;  5 &amp;    &amp; 14 &amp;    &amp; 30 &amp;    &amp; 55 &amp;    &amp; 91 &amp; \<br>&amp;  4 &amp;    &amp;  9 &amp;    &amp; 16 &amp;    &amp; 25  &amp;    &amp; 36 &amp; \<br>&amp;    &amp;  5 &amp;    &amp;  7 &amp;    &amp;  9 &amp;    &amp;  11 &amp; \<br>&amp;    &amp;    &amp;  2 &amp;    &amp;  2 &amp;    &amp;  2 &amp; \<br>\end{array}<br>$$</p><p>第一行为 $f(x)$ 的连续的前 $n$ 项；之后的每一行为之前一行中对应的相邻两项之差。观察到，如果这样操作的次数足够多（前提是 $f(x)$ 为多项式），最终总会返回一个定值。</p><p>计算出第 $i-1$ 阶差分的首项为 $\sum_{j=1}^{i}(-1)^{i+j}\binom{i-1}{j-1}f(j)$，第 $i-1$ 阶差分的首项对 $f(k)$ 的贡献为 $\binom{k-1}{i-1}$ 次。</p><p>$$<br>f(k)=\sum_{i=1}^n\binom{k-1}{i-1}\sum_{j=1}^{i}(-1)^{i+j}\binom{i-1}{j-1}f(j)<br>$$</p><p>时间复杂度为 $O(n^2)$。这种方法对给出的点的限制性较强。</p><h1>待定系数法</h1><p>设 $f(x)=\sum_{i=0}^{n-1} a_ix^i$ 将每个 $x_i$ 代入 $f(x)$，有 $f(x_i)=y_i$，这样就可以得到一个由 $n$ 条 $n$ 元一次方程所组成的方程组，然后使用 <strong>高斯消元</strong> 解该方程组求出每一项 $a_i$，即确定了 $f(x)$ 的表达式。</p><p>时间复杂度 $O(n^3)$，对给出点的坐标无要求。</p><h1>拉格朗日插值</h1><p>$$<br>f(x)=\sum_{i=1}^n{y_i\prod_{j\ne i}{\dfrac {x-x_j}{x_i-x_j}}}<br>$$</p><p>这就是拉格朗日插值的表达式。</p><p>本题中，还需要求解逆元。如果先分别计算出分子和分母，再将分子乘进分母的逆元，累加进最后的答案，时间复杂度的瓶颈就不会在求逆元上，时间复杂度为 $O(n^2)$。</p><h2 id="横坐标是连续整数的拉格朗日插值">横坐标是连续整数的拉格朗日插值</h2><p>如果已知点的横坐标是连续整数，我们可以做到 $O(n)$ 插值。</p><p>设要求 $n$ 次多项式为 $f(x)$，我们已知 $f(1),\cdots,f(n+1)$（$1\le i\le n+1$），考虑代入上面的插值公式：</p><p>$$<br>\begin{aligned}<br>f(x)&amp;=\sum\limits_{i=1}^{n+1}y_i\prod\limits_{j\ne i}\frac{x-x_j}{x_i-x_j}\<br>&amp;=\sum\limits_{i=1}^{n+1}y_i\prod\limits_{j\ne i}\frac{x-j}{i-j}<br>\end{aligned}<br>$$</p><p>后面的累乘可以分子分母分别考虑，不难得到分子为：</p><p>$$<br>\dfrac{\prod\limits_{j=1}^{n+1}(x-j)}{x-i}<br>$$</p><p>分母的 $i-j$ 累乘可以拆成两段阶乘来算：</p><p>$$<br>(-1)^{n+1-i}\cdot(i-1)!\cdot(n+1-i)!<br>$$</p><p>于是横坐标为 $1,\cdots,n+1$ 的插值公式：</p><p>$$<br>f(x)=\sum\limits_{i=1}^{n+1}y_i\cdot\frac{\prod\limits_{j=1}^{n+1}(x-j)}{(x-i)\cdot(-1)^{n+1-i}\cdot(i-1)!\cdot(n+1-i)!}<br>$$</p><p>预处理 $(x-i)$ 前后缀积、阶乘阶乘逆，然后代入这个式子，复杂度为 $O(n)$。</p><h3 id="CF622F-The-Sum-of-the-k-th-Powers"><a href="https://codeforces.com/contest/622/problem/F">CF622F The Sum of the k-th Powers</a></h3><p>$$<br>f(x)=\sum_{i=1}^{n+1}\binom{x-1}{i-1}\sum_{j=1}^{i}(-1)^{i+j}\binom{i-1}{j-1}y_{j}=\sum\limits_{i=1}^{n+1}y_i\cdot\frac{\prod\limits_{j=1}^{n+1}(x-j)}{(x-i)\cdot(-1)^{n+1-i}\cdot(i-1)!\cdot(n+1-i)!}<br>$$</p><h4 id="分析">分析</h4><p>由于差分之后常系数是 $i^k$ 那么可以推出他是 $k+1$ 次多项式，只需求 $k+2$ 个点就能唯一确定了。</p><h3 id="part-1：普通-O-n-2">part 1：普通 $O(n^2)$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;T f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)&#123;f=<span class="number">-1</span>;&#125;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> x[N],y[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=<span class="number">1ll</span>*res*a%mod;</span><br><span class="line">a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x[i]),<span class="built_in">read</span>(y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> res=y[i];</span><br><span class="line">        <span class="type">int</span> res1=<span class="number">1</span>,res2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">            res1=(<span class="number">1ll</span>*res1*(k-x[j]))%mod;</span><br><span class="line">            res2=(<span class="number">1ll</span>*res2*(x[i]-x[j]))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*res*res1%mod*<span class="built_in">qmi</span>(res2,mod<span class="number">-2</span>)%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>((ans+mod)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="part2：O-n-值域连续。">part2：O(n) 值域连续。</h3>]]></content>
    
    
    <summary type="html">拉格朗日差值学习笔记</summary>
    
    
    
    <category term="拉格朗日差值" scheme="https://uicere.github.io/category/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%B7%AE%E5%80%BC/"/>
    
    
    <category term="数学" scheme="https://uicere.github.io/tag/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CSP</title>
    <link href="https://uicere.github.io/article/6/"/>
    <id>https://uicere.github.io/article/6/</id>
    <published>2023-08-30T12:15:44.000Z</published>
    <updated>2023-08-31T01:58:42.383Z</updated>
    
    <content type="html"><![CDATA[<h1>策略游戏</h1><p>分类讨论即可。<br><img src="image.png" alt="Alt text"></p><h1>假期计划</h1><p>贪心选，预处理可以到家的并且距离 $u$ 前 $3$ 大的即可，$O(n^2)$ 枚举即可。</p><h1>星战</h1><p>出度转入度，每个点的出度都是 $1$ 的时候满足条件。</p><p>出度均为 $1$ 的必要条件是，入度和为 $n$，但是不是充分条件，因此我们考虑哈希，减少冲突性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;策略游戏&lt;/h1&gt;
&lt;p&gt;分类讨论即可。&lt;br&gt;
&lt;img src=&quot;image.png&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;h1&gt;假期计划&lt;/h1&gt;
&lt;p&gt;贪心选，预处理可以到家的并且距离 $u$ 前 $3$ 大的即可，$O(n^2)$ 枚举即可。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="真题" scheme="https://uicere.github.io/tag/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>组合数学</title>
    <link href="https://uicere.github.io/article/1/"/>
    <id>https://uicere.github.io/article/1/</id>
    <published>2023-08-29T16:00:00.000Z</published>
    <updated>2023-09-03T23:46:12.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加法和乘法原理">加法和乘法原理</h2><p>基本：</p><p>分类考虑加法原理。</p><p>分步考虑乘法原理。</p><h2 id="排列组合">排列组合</h2><p>盒子与球都有标号。<br>$$A_n^m=n(n-1)(n-2)\dotsb (n-m+1)=\frac{n!}{(n-m)!}$$<br>盒子无标号，球有标号。<br>$$C_n^m=\frac{n(n-1)(n-2)\dotsb (n-m+1)}{m!}=\frac{n!}{m!(n-m)!}$$<br>组合相对于排列的区别就是去掉了顺序，<strong>对于 $n&gt;m,{n \choose m}=0$</strong>。</p><h2 id="color-red-二项式定理">$\color{red}{二项式定理}$</h2><p>设 $n$ 是正整数，对一切 $x$ 和 $y$ 有：<br>$$(x+y)^n=\sum_{k=0}^n {n \choose m}x^ky^{n-k}\<br>\Longrightarrow (ax+by)^n=\sum_{k=0}^n {n \choose m}a^k x^kb^{n-k}y^{n-k}$$</p><h3 id="color-blue-NOIP2011-提高组-计算系数">$\color{blue}{[NOIP2011 提高组] 计算系数}$</h3><p><a href="https://www.luogu.com.cn/problem/P1313">P1313 [NOIP2011 提高组] 计算系数</a></p><p><strong>给定一个多项式</strong> $(by+ax)^k$，<strong>已知</strong> $a,b,k,n,m$ <strong>请求出多项式展开后</strong> $x^n\times y^m$ <strong>项的系数</strong>。</p><p>$0\le k\le 1000$，$0\le n,m\le k$，$n+m=k$，$0\le a,b\le 10^6$。</p><p><strong>结果就是</strong> ${k \choose m}a^nb^m$，<strong>当且仅当</strong> $n+m=k$。</p><h2 id="组合数基本公式">组合数基本公式</h2><p>$${n \choose m}={n-1 \choose m-1}+{n-1 \choose m}  \tag{1}$$</p><p>$${n \choose m}={n\choose n-m}\tag{2}$$</p><p>$${n \choose m}={\frac{n}{k}}{n-1\choose k-1} \tag{3}$$</p><p>$$\binom{n}{0}+\binom{n}{1}+\cdots+\binom{n}{n}=\sum_{i=0}^n\binom{n}{i}=2^n\tag{4}$$</p><p>$$\sum_{i=0}^n(-1)^i\binom{n}{i}=[n=0]\tag{6}$$</p><p>$${n+r+1 \choose r}=\sum_{i=0}^{r}{n+i \choose i} \tag{7}$$</p><hr><p>证：<br>$${n+r+1 \choose r}={n+r \choose r}+{n+r \choose r-1}$$</p><p>$${n+r+1 \choose r}={n+r \choose r}+{n+r-1 \choose r-1}+{n+r-1 \choose r-2}$$</p><p>展开最后一项直至最后一项为 ${0 \choose -1}$ ,无意义为 $0$。</p><p>证毕</p><hr><p>$$<br>{n \choose m}\times {m \choose r}={n\choose r}\times {n-r \choose m-r}\tag{8}<br>$$</p><p>$$<br>m\times {n \choose m}=n\times {n-1 \choose m-1}\tag{9}<br>$$</p><hr><p>证：</p><p>据上式 $r=1$ 得证</p><p>证毕</p><hr><p>$${n+m \choose r}=\sum_{i=0}^r{n\choose i}\times {m \choose r-i}\tag{10}$$</p><hr><p>证：</p><p>组合意义，分成 $n,m$，枚举一边，另一边对应。</p><p>证毕</p><hr><p>$$\sum_{i=0}^ni\times {n\choose i}=n\times 2^{n-1}\tag{11}$$</p><hr><p>证：</p><p>据<br>$m\times {n \choose m}=n\times {n-1 \choose m-1}$得</p><p>$$\sum_{i=0}^nn\times {n-1 \choose i-1}$$<br>$$ n\times \sum_{i=0}^n {n-1 \choose i-1}$$<br>令 $i^{'}=i-1$，根据二项式定理<br>$$ n\times \sum_{i=0}^n {n-1 \choose i-1}<br>=n\times 2^{n-1}$$<br>则，<br>$$\sum_{i=0}^ni\times {n\choose i}=n\times 2^{n-1}<br>$$</p><p>证毕</p><hr><h2 id="插板法">插板法</h2><p>$x_1+x_2+x_3+x_4+x_n=k$ 的正整数解的组数。</p><p>${k-1 \choose n-1}$</p><hr><p>$x_1+x_2+x_3+x_4+x_n=k$ 的非负整数解的组数。</p><p>${k-1+n \choose n-1}$</p><hr><p>$x_1+x_2+x_3+x_4+x_n=k$ 满足 $x_i \ge a_i$的组数。</p><p>${k-1-\sum a_i +n \choose n-1}$</p><hr><h2 id="不相邻排列">不相邻排列</h2><p>$1 \sim n$ 这 $n$ 个自然数中选 $k$ 个，这 $k$ 个数中任何两个数都不相邻的组合有 $\binom {n-k+1}{k}$ 种。</p><p><a href="https://www.luogu.com.cn/problem/P4071">P4071 [SDOI2016] 排列计数</a></p><p>求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。</p><p><a href="https://www.luogu.com.cn/blog/starseven/solution-p4071">思路1easy</a></p><p><a href="https://bubbleioa.blog.luogu.org/solution-p4071">思路2hard</a></p><h2 id="离散与组合数学">离散与组合数学</h2><h3 id="多重集合">多重集合</h3><p>定义：多重集是指包含<strong>重复元素</strong>的广义集合。</p><h3 id="多重集上的排列">多重集上的排列</h3><p><strong>多重集的排列数</strong>：</p><p>设 $S={n_1\cdot a_1,n_2\cdot a_2,\cdots,n_k\cdot a_k}$ 表示由 $n_1$ 个 $a_1$，$n_2$ 个 $a_2$，…，$n_k$ 个 $a_k$ 组成的多重集，$S$ 的全排列个数为<br>$$\frac{n!}{\prod_{i=1}^kn_i!}=\frac{n!}{n_1!n_2!\cdots n_k!}$$</p><p>多重集的排列数常被称作 <strong>多重组合数</strong>，形如以下：</p><p>$$\binom{n}{n_1,n_2,\cdots,n_k}=\frac{n!}{\prod_{i=1}^kn_i!}$$</p><p>e.g.$\dbinom{n}{m} \iff \dbinom{n}{m,n-m}$</p><h3 id="多重集上的组合">多重集上的组合</h3><h4 id="错排列">错排列</h4><p>令 $x=1,y=1$ , $\sum_{i=0}^{n}C_n^i=2^i$。</p><p>令 $x=1,y=-1$ , $\sum_{i=0}^{n}(-1)^i \times C_n^i=[n=0]$</p><p>假设存在两个函数 $f$，$g$。满足：</p><p>$$ f_n=\sum_{i=0}^{n}C_n^i \times g_i $$</p><p>那么考虑如何反求得 $g_n$ 关于 $f_n$ 的等式。</p><p>$$ g_n=\sum_{i=0}^{n}[n-i=0] \times C_n^i \times g_i\ g_n=\sum_{i=0}^{n}\sum_{j=0}^{n-i}(-1)^j \times C_{n-i}^j \times C_n^i \times g_i\ g_n=\sum_{i=0}^{n}\sum_{j=0}^{n-i}(-1)^j \times C_{n}^j \times C_{n-j}^i \times g_i\ g_n=\sum_{j=0}^{n}(-1)^j \times C_n^j\sum_{i=0}^{n-j}C_{n-j}^i \times g_i\ g_n=\sum_{i=0}^{n}(-1)^i \times C_n^i \times f_{n-i}=\sum_{i=0}^{n}(-1)^{n-i} \times C_n^i \times f_{i} $$<br>所以得到二项式反演的结论：</p><p>$$ f_n=\sum_{i=0}^{n}C_n^i \times g_i\ g_n=\sum_{i=0}^{n}(-1)^{n-i} \times C_n^i \times f_{i}\ $$</p><hr><p>问题描述：</p><p>有 $n$ 个人编号为 $1, …, n$ ，问这 $n$ 个人站成一排全都站错位置的方案数。</p><p>上述站错的定义是：第 $i$ 个人没有站在位置 $i$ 上。</p><p><strong>方法1</strong>： 递推<br>设 $f_n$ 表示答案，假设现在考虑到了前 $i$ 个人的方案，即 $f_i$ 。</p><p>考虑第 $i$ 个人站位情况：</p><p>显然第 $i$ 个人的不能站在位置 $i$ ，假设他站到了位置 $k$ ，显然 $k\in[1,i-1]$ ，那么继续考虑 $k$ 的站位。</p><ul><li><p>$k$ 站到了位置i，那么剩下的 $i-2$ 个人仍然构成一个原问题，方案数为 $f_{i-2}$ 。</p></li><li><p>$k$ 没站到位置i，也即 $k$ 不能站在位置 $i$ ，那么剩下的 $i-1$ 个人仍然构成一个原问题，方案数为 $f_i-1$ 。</p></li></ul><p>所以可以得到 $f$ 的递推关系：</p><p>$$ f_1=0\ , \ f_2=1\f_i=(i-1) \times (f_{i-1}+f_{i-2})\ \ i≥3 $$<br><strong>方法2</strong>：二项式反演<br>设 $f_n$ 表示 $n$ 个人随便站位的方案数， $g_n$ 表示 $n$ 个人的都站错的方案数。</p><p>容易得到：</p><p>$$ f_n=n!\ f_n=\sum_{i=0}^nC_n^i \times g_i $$<br>直接二项式反演可以得到：</p><p>$$ g_n=\sum_{i=0}^{n}(-1)^{n-i} \times C_n^i \times f_{i}\ $$<br>同样可以直接线性的递推出答案。</p><hr><h2 id="圆排列">圆排列</h2><p>$n$ 个人全部来围成一圈，所有的排列数记为 $\mathrm Q_n^n$。考虑其中已经排好的一圈，从不同位置断开，又变成不同的队列。<br>所以有</p><p>$$<br>\mathrm Q_n^n \times n = \mathrm A_n^n \Longrightarrow \mathrm Q_n = \frac{\mathrm A_n^n}{n} = (n-1)!<br>$$</p><p>由此可知部分圆排列的公式：</p><p>$$<br>\mathrm Q_n^r = \frac{\mathrm A_n^r}{r} = \frac{n!}{r \times (n-r)!}<br>$$</p><h2 id="鸽巢原理-抽屉原理">鸽巢原理/抽屉原理</h2><p>反证法，构造题。</p><h2 id="容斥原理">容斥原理</h2><h2 id="卡特兰">卡特兰</h2><h3 id="递推式">递推式</h3><p>该递推关系的解为：</p><p>$$<br>H_n = \frac{\binom{2n}{n}{n+1}}(n \geq 2, n \in \mathbf{N_{+}})<br>$$</p><p>关于 Catalan 数的常见公式：</p><p>$$<br>H_n = \begin{cases}<br>\sum_{i=1}^{n} H_{i-1} H_{n-i} &amp; n \geq 2, n \in \mathbf{N_{+}}\<br>1 &amp; n = 0, 1<br>\end{cases}<br>$$</p><p>$$<br>H_n = \frac{H_{n-1} (4n-2)}{n+1}<br>$$</p><p>$$<br>H_n = \binom{2n}{n} - \binom{2n}{n-1}<br>$$</p><p>路径计数问题。</p><h2 id="枚举所有子集复杂度">枚举所有子集复杂度</h2><p>枚举 $S$ 的所有子集的子集的时间复杂度是 $O(3^n)$<br>考虑一种常见的枚举子集方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s 是 u 的一个非空子集 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = u; s; s = (s - <span class="number">1</span>) &amp; u)</span><br></pre></td></tr></table></figure><p>显然单次枚举 $S$ 的一个子集是 $O(2^{|S|})$ 的。</p><p>复杂度证明：</p><p>$$O\left(\sum_{T\subseteq S}2^{|T|}\right)$$</p><p>不难发现，$S$ 中大小为 $l$ 的子集个数是 $\dbinom nl$，这是简单的组合数学知识。</p><p>转而枚举 $l$，于是原式就化为</p><p>$$O\left(\sum_{i=1}^n\dbinom ni 2^i\right) $$</p><p>根据二项式定理：</p><p>$$\begin{aligned}<br>&amp;=\sum_{i=1}^n \dbinom ni 2^i<br>\&amp;=\sum_{i=1}^n \dbinom ni 2^i1^{n-i}\<br>&amp;=(1+2)^n-1\<br>&amp;=3^n-1\end{aligned}<br>$$</p><p>于是，枚举 $S$ 的所有子集的子集的时间复杂度是 $O(3^n)$ 的。</p><p>证毕。</p><h2 id="反演">反演</h2><p>反演：两个函数或者数列之间的双向（求和）关系</p><p>比如前缀和 $and$ 差分。</p><p>$f(n) = \sum_{i = 0}^ng(i)$ 就是前缀和</p><p>$g(n) = f(n) - f(n - 1)$ 就是差分</p><p>这一对关系就是双向的求和关系。</p><p>当然这么说的话，求导和积分也就是双向的关系，那么他们也是符合反演的。</p><p>定义 $A$ 为关系矩阵。</p><p>有 $f = g \times A$，也有 $g = f \times A^{-1}$。</p><h2 id="二项式反演">二项式反演</h2><p>形式一</p><p>$$<br>f(n) = \sum_{i = 0}^n(- 1)^i \binom{n}{i} g(i)<br>$$</p><p>$$<br>g(n) = \sum_{i = 0}^n(-1)^i \binom{n}{i} f(i)<br>$$</p><p>形式二</p><p>$$<br>f(n) = \sum_{i = 0}^n\binom{n}{i}g(i)<br>$$</p><p>$$<br>g(n) = \sum_{i = 0}^n(-1)^{n - i}\binom{n}{i}f(i)<br>$$</p><p>形式三</p><p>$$<br>f(n) = \sum_{i = n}(-1)^i\binom{i}{n}g(i)<br>$$</p><p>$$<br>g(n) = \sum_{i = n}(-1)^{i - n}\binom{i}{n}f(i)<br>$$</p><p>形式四</p><p>$$<br>f(n) = \sum_{i = n}(-1)^i\binom{i}{n}g(i)<br>$$</p><p>$$<br>g(n) = \sum_{i = n}(-1)^i\binom{i}{n}f(i)<br>$$</p><p>这些形式都是非常对称的。</p><p>也就是说 $A[n, i] = (-1)^i\binom{n}{i}$ 是自逆的。</p><p>证：<br>$$<br>(A * A) [d, t] = \sum_{i}A[d, i] A[i, t]<br>$$</p><p>$$<br>= \sum_{i = t}^d(-1)^i\binom{d}{i}(-1)^t\binom{t}{i}<br>$$</p><p>$$<br>= (-1)^t\sum_{i = t}^d(-1)^{i}\frac{d!i!}{i!(d - i)!t!(i - t)!}<br>$$</p><p>$$<br>= (-1)^t\sum_{i = t}^d(-1)^{i}\frac{d!(d - t)!}{(d - t)!(d - i)!t!(i - t)!}<br>$$</p><p>$$<br>\frac{d!}{t!(d - t)!} \cdot \frac{(d - t)!}{(d - i)!(i - t)!}<br>$$</p><p>$$<br>= \binom{d}{t} \cdot \binom{d - t}{d - i}<br>$$</p><p>$$<br>So:<br>$$</p><p>$$<br>= (-1)^t\binom{d}{t}\sum_{i = t}^d(-1)^i\binom{d - t}{d - i}<br>$$</p><p>$$<br>= (-1)^t\sum_{i = 0}^{d - t}(-1)^{i + t}\binom{d - t}{d - t - i}<br>$$</p><p>$$<br>= (-1)^t(-1)^t\binom{d}{t}\sum_{i = 0}^{d - t}(-1)^i\binom{d - t}{i}<br>$$</p><p>$$<br>= (-1)^t(-1)^t\binom{d}{t}(1 - 1)^{d - t}<br>$$</p><p>$$<br>= (-1)^{2t}\binom{d}{t}(1 - 1)^{d - t} = [d = t]<br>$$</p><p>这里的 $(1 - 1)^0 = 0^0$ 为什么是 $1$？（反正当时我是有这个疑惑，记得文化课老师说不能是$1$，但并不知道凭啥不能是 $1$？这个说法到底对不对？？？）</p><p>有些人将 $0$ 不能是分母和这个的原因搞混了。 $0$ 不能是分母是因为其会使运算变得混乱，</p><p>而这个是不是 $1$ 都可以。</p><p>可能需要用到集合论的知识。</p><p>要证明$a^0 = 1$ 需要给出映射的定义：</p><ol><li><p>$f$ 是 $X$ 和 $Y$ 的笛卡尔积的子集。</p></li><li><p>对于任意 $x \in X$ ，存在一定的 $y \in Y$ ，使得 $(x, y) \in f$， 也就是常说的 $y = f(x)$，在集合论中对函数的定义是集合之间的映<br>射关系。</p></li></ol><p>定义基数：定义 $a^b$ 是由基数为 $b$ 到基数为 $a$ 的集合的映射全体所构成集合的基数。</p><p>考虑 $a^0$ 的情况，由一个空集到某一个基数为 $a$ 的集合的映射有多少个。答案是有一个，空映射。为什么空集可以形成映射？看第一条，空集满足了。</p><p>看第二条，空集也是满足的。因为数理逻辑里面讲（参考《离散数学》）若 $p$，则 $q$&quot; 在 $p$ 是 $false$ 的时候，这个命题是恒真的。</p><p>为什么呢？可以举一个很形象的例子：人们常会说：“如果太阳打西边出来，那我就不姓$Y$ 。” 在这句话里面不管 “我” 姓不姓 $Y$，太阳都是</p><p>从东边出来的。也就是说这个 $p$ 对 $q$ 是没有什么影响的。并且在数理逻辑下，$p$ 和 $q$ 可以没有任何的内在联系，请和自然语言进行区分。</p><p>这里对 $a$ 并没有加以任何限制，也就是说 $a = 0$ 也是可以的，所以 $0^0 = 1$。</p><p>但这个又可以通过代数系统解释出：由于 $0$ 没有逆元，所以 $0^0$ 没有意义，或不存在。</p><h2 id="莫比乌斯反演">莫比乌斯反演</h2><p>克罗内克函数<br>$$<br>\delta(x, y) = \begin{cases}<br>&amp; \text{1} \space\space x = y \<br>&amp; \text{0} \space\space \text{otherwise}<br>\end{cases}<br>$$</p><p>黎曼函数<br>$$<br>\zeta(x, y) = \begin{cases}<br>&amp; \text{1} \space\space x \le x y \<br>&amp; \text(0) \space\space \text{otherwise}<br>\end{cases}<br>$$</p><p>这里的克罗内克函数和黎曼函数均为二变量函数。</p><p>当克罗内克函数和黎曼函数的第一个变量都为 $1$ 时，我们得出了完全积性函数$\varepsilon$ 和 $I$ 的定义。</p><p>$$<br>So:<br>\begin{cases}<br>&amp; \zeta(1, n)  = I(n) \<br>&amp; \delta(1, n) = \varepsilon<br>\end{cases}<br>$$</p><p>$And:$</p><p>$\mu$ 是一个二变量函数 $\mu(x, y)$ ，定义为 $\zeta$ 的逆函数。</p><p>$<br>\mu * \zeta = \delta<br>$</p><p>$<br>\sum_{x \le z \le y}\mu(x, z) = \delta(x, y)<br>$</p><p>莫比乌斯反演定理：</p><p>$$<br>G(x) = \sum_{z \le x} F(z) \Longrightarrow F(x) = \sum_{y \le x}G(y)\mu(y, x)<br>$$</p><p>证明：<br>$$<br>= \sum_{y \le x}\mu(y, x)\sum_{z \in X}\zeta(z, y)F(z)\<br>= \sum_{z \in X}\sum_{y \le x}\mu(y, x)\zeta(z, y)F(z)\<br>$$</p><p>$$<br>= \sum_{z \in X}\delta(z, x)F(z) = F(x)<br>$$</p><p>在实际应用中常使用莫比乌斯函数的 $\mu(1, n)$ 的形式，缩写为 $\mu(n)$，当然你也可以说我们常用到的莫比乌斯函数是 $I$ 的逆函数 $I^{-1}$，大佬莫比乌斯将其命名为 $\mu$。</p><p>当然也可以通过这个了解 $\mu$ 取值的定义。</p><p>$So$ 也就有了这个：</p><p>$$<br>F(n) = \sum_{d | n}f(d)<br>$$</p><p>$$<br>g(d) = \sum_{d | n}\mu(d)g(\frac{n}{d})<br>$$</p><p>自然这个也可以通过$Dirichlet$ 卷积和积性函数来解释。</p><p><a href="https://www.luogu.com.cn/blog/817044/Dirichlet">狄利克雷卷积 My blog</a>。</p><p>由于这篇博客写的时间较早，可能无法谈到更深层的东西，还请见谅。</p><h2 id="子集反演">子集反演</h2><p>$$<br>g(S) = \sum_{T \subset S}f(T)<br>$$</p><p>$$<br>f(S) = \sum_{T \subset S}(-1)^{|S| - |T|} g(T)<br>$$</p><p>（一眼看上去，感觉这玩意就纯抽象，比二项式反演还要抽象， 为啥要学这个玩意啊，草。）</p><p>证明：</p><p>$$<br>\sum_{T \subset S}(-1)^{|S| - |T|}g(T)<br>$$</p><p>$$<br>= \sum_{T \subset S}(-1)^{|S| - |T|}\sum_{R \subset T}f®<br>$$</p><p>$$<br>= \sum_{R \subset S}f® \sum_{R \subset T \subset S}(-1)^{|S| - |T|}<br>$$</p><p>当 $R = S$ ，可以得知 $\sum_{R \subset T \subset S} (-1)^{|S| - |T|} = 1$，否则任取 $a \in S - R$，$f : T \mapsto  T \oplus {a}$ 是双射，故 $\sum_{R \subset T \subset S} (-1)^{|S| - |T|} = 0$</p><p>正好难算，至多好算： $f(S) = \sum_{T \subset S}g(T) \Longrightarrow  g(S) = \sum_{T \subset S}(-1)^{|S| - |T|}f(T)$</p><p>正好难算，至少好算： $f(S) = \sum_{S \subset T}g(T)<br>\Longrightarrow  g(S) = \sum_{S \subset T}(-1)^{|T| - |S|}f(T)$</p><p>推广莫比乌斯函数：</p><p>$$<br>\mu(S) = (-1)^{|S|}[S \space has \space no \space duplicate \space elements]<br>$$</p><p>【莫比乌斯函数就是把整数当作质因数集合而来的反演系数！】</p><p>这个有点妙啊！</p><p>$$<br>f(S) = \sum_{T \subset S}g(T) \Longrightarrow g(S) = \sum_{T \subset S} \mu(S - T)f(T)<br>$$</p><p>$$<br>f(S) = \sum_{S \subset T}g(T) \Longrightarrow g(S) =<br>\sum_{T \subset S} \mu(T - s)f(T)<br>$$</p><p>证明：</p><p>$\mu(A, A) = 1$</p><p>设 $B\ne A, \space p = |B| - |A|$</p><p>$$<br>\mu(A, B)<br>$$</p><p>$$<br>= -\sum_{C: A \subseteq C \subset B} \mu(A, C)<br>$$</p><p>$$<br>= -\sum_{C: A \subseteq C \subset B}(-1)^{|C| - |A|}<br>$$</p><p>$$<br>= -\sum_{k = 0}^{p - 1}(-1)^k\binom{P}{k}<br>$$</p><p>$$<br>= -(-(-1)^p\binom{P}{P} + \sum_{k = 0}^p(-1)^k\binom{P}{k})<br>$$</p><p>$$<br>= (-1)^p\binom{P}{P}<br>$$</p><p>$$<br>= (-1)^{|B| - |A|}<br>$$<br>—— 转载自$JLQ’s Blog$</p><p>这也就是上面那样转化成立的原因。</p><h1>求组合数</h1><ul><li>有模数<ul><li>模数小 $(Lucas)$</li><li>预处理</li></ul></li><li>无模数质因数分解</li></ul><p><a href="https://www.luogu.com.cn/blog/483037/qian-tan-bo-yi-lun">博弈论之NIM游戏</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;加法和乘法原理&quot;&gt;加法和乘法原理&lt;/h2&gt;
&lt;p&gt;基本：&lt;/p&gt;
&lt;p&gt;分类考虑加法原理。&lt;/p&gt;
&lt;p&gt;分步考虑乘法原理。&lt;/p&gt;
&lt;h2 id=&quot;排列组合&quot;&gt;排列组合&lt;/h2&gt;
&lt;p&gt;盒子与球都有标号。&lt;br&gt;
$$A_n^m=n(n-1)(n-2)&#92;dots</summary>
      
    
    
    
    
    <category term="数学" scheme="https://uicere.github.io/tag/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2023spring</title>
    <link href="https://uicere.github.io/article/5/"/>
    <id>https://uicere.github.io/article/5/</id>
    <published>2023-08-29T16:00:00.000Z</published>
    <updated>2023-08-31T01:58:39.585Z</updated>
    
    <content type="html"><![CDATA[<h1>涂色游戏</h1><p>涂色会覆盖之前，因此只需要记录每个格子涂色的时间戳，就可唯一确定最终颜色。</p><h1>幂次</h1><p>在 $1$ 到 $n$ 中，有多少<strong>正整数</strong> $x$ 可以被表示为 $x = a^b$ 的形式，其中 $a, b$ 都是<strong>正整数</strong>，且 $b \geq k$。</p><p>对于所有数据，保证 $1 \leq n \leq 10^{18}$，$1 \leq k \leq 100$。</p><p>此题的关键点就是 $n$ 的范围很大，因此我们考虑容斥。</p><p>对于 $k=1$，有 $\sqrt[1]{n}$ 个，已经包含所有数，无需在讨论后续。</p><p>对于 $k=2$，有 $\sqrt[2]{n}$ 个,约有 $1e9$ 个，但是我们知道 对于 $1-n$ 中共有 $\lfloor\sqrt[2]{n}\rfloor$ 个平方数，这类似于 $1-n$ 中共有 $\lfloor \frac{n}{k} \rfloor$ 个 k 的倍数，因此只要把对于 $k&gt;2$ 的重复统计的容斥掉即可。</p><p>对于 $k&gt;3$，有 $\sqrt[3]{n}$ 个，是 $1e6$ 因此暴力枚举即可。</p><p>$\color{red}{对于k&gt;3记得记录1的贡献}$。</p><p>这是在优化暴力枚举+基础数论知识。</p><p>复杂度  $O(\sqrt[3]{n})$，<strong>这个非常不严谨，但是我不会算了。</strong></p><h3 id="还有更优秀的解法，但是不好想">还有更优秀的解法，但是不好想</h3><p>设 $g_i$  为 $[1,n]$ 中，$x=a^i$ 的个数，显然 $g_i$ 为 $\sqrt[i]{n}$。</p><p>设 $f_i$ 为 $[1,n]$ 中，$x=a^i$ 但是对于 $j&gt;i$，$x_j \neq x_i$。</p><p>因此答案为</p><p>$$ans= \sum_{i=k}^{60}f_i$$<br>因为 $2^{60}&gt;1e18$，所以到 $60$ 即可。</p><p>因此求得 $f_i$ 只需容斥即可。<br>$$f_i=g_i-\sum_{idx=2}^{k}f_{i\times idx}$$</p><p>含义就是减去所有可以组成他的次幂，因为 $a^i \supseteq a^{2i}$，所以容斥掉即可。</p><p>$\color{red}{对于1我们默认先删除，到最后答案 +1 即可}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">60</span>;i&gt;=k;i--)&#123;</span><br><span class="line">f[i]=<span class="built_in">pow</span>&lt;<span class="type">long</span> <span class="type">double</span>&gt;(n,<span class="number">1.0</span>/i)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll j=i*<span class="number">2</span>*;j&lt;=<span class="number">60</span>;j+=i) f[i]-=f[j];</span><br><span class="line">ans+=f[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度 $O(k \log k)$</p><h1>圣诞树</h1><p><strong>逆时针编号</strong>依次给定凸包的坐标，让球从凸包最高点 $m$ 最终走完所有顶点的最短距离。</p><p>逆时针是对写 $dp$ 方便的。</p><h5 id="color-red-最小生成树是假做法">$\color{red}{最小生成树是假做法}$</h5><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/16pv1w8l.png" alt=""><br>显然这是假的。</p><p>考虑正解，对于给定了起点，我们先猜测若路径有交叉，显然不是最优，可以四边形不等式即可证明。</p><p>对于至高点两边，在同一侧运动显然是每次直走一个编号的距离，这样一定是最优的，因为隔着走肯定还得返回，路径必然有相交，而且肯定是从最高点每次走离自己比较近的点，依次向下，证明显然。</p><p>这题在求出最优的同时还有求解路径，还要保存路径，这个只需在每次转移最优的时候记录一下，最后逆推即可。</p><p>因为一直是向前走，$dp$ 无后效性可以记录路径。</p><p>因此考虑区间 $dp$。</p><p>设 $f_{i,j,0/1}$ 表示为已经走了 $i+j$ 步，至高点左边已经选了 $i$ 个节点，右边已经选择了 $j$ 个节点当前在左边0还是右边1的最短路径。<br>一下对于不合法编号自动考虑 $+n$ 或 $-n$ 成为合法的。<br>$$</p><p>f_{i,j,0}=min(f_{i-1,j,0}+dist(m+i-1,m+i),f_{i-1,j,1}+dist(m+i,m-j))\<br>f_{i,j,1}=min(f_{i,j-1,1}+dist(m-j+1,m-j),f_{i,j-1,0}+dist(m+i,m-j))</p><p>$$</p><p>显然是合法且保证正确的。</p><h1>密码锁</h1><p>给定一个锁，对于每个拨圈可以上下依次移动。</p><p>对于 $1 \leq i \leq k$，定义密码锁第 $i$ 行的松散度为</p><p>$$<br>c(i) = \max \limits _ {j = 1} ^ n a _ {i, j} - \min \limits _ {j = 1} ^ n a _ {i, j}<br>$$</p><p>同时定义整个密码锁的松散度为</p><p>$$<br>C = \max \limits _ {1 \leq i \leq k} c(i)<br>$$</p><p>求最小的 $C$ 值。</p><p>对于所有数据，保证 $1 \leq T$，$1 \leq k \leq 4$，$1 \leq a _ {i ,j} \leq  3 \times 10 ^ 4$。</p><hr><p>考虑随机化，对于该问题我们最难确定的就是对这个矩阵，我们对于其中任意一个元素都难以确定其位置，那我们就考虑先固定住一列，剩下的列在求解，多随机几次一定能获得正解，因为随机一次的复杂度仅有 $nk^2$，随机 $400$ 次这一定是可以获得正解的。</p><h2 id="随机就是写个随机，模拟求解一下答案">随机就是写个随机，模拟求解一下答案</h2><!-- # 学了个新东西，就是他 --><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">g</span><span class="params">(chrono::_V2::steady_clock::now().time_since_epoch().count())</span></span>;</span><br></pre></td></tr></table></figure><h6 id="color-green-正解，先鸽了">$\color{green}{正解，先鸽了}$</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;涂色游戏&lt;/h1&gt;
&lt;p&gt;涂色会覆盖之前，因此只需要记录每个格子涂色的时间戳，就可唯一确定最终颜色。&lt;/p&gt;
&lt;h1&gt;幂次&lt;/h1&gt;
&lt;p&gt;在 $1$ 到 $n$ 中，有多少&lt;strong&gt;正整数&lt;/strong&gt; $x$ 可以被表示为 $x = a^b$ 的形式，其中 </summary>
      
    
    
    
    
    <category term="真题" scheme="https://uicere.github.io/tag/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>NOIP</title>
    <link href="https://uicere.github.io/article/9/"/>
    <id>https://uicere.github.io/article/9/</id>
    <published>2023-08-29T16:00:00.000Z</published>
    <updated>2023-09-04T13:50:56.665Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>NOIP 2021</strong></h1><h2 id="报数"><strong>报数</strong></h2><p>水题，筛法解决。</p><h2 id="数列"><strong>数列</strong></h2><p><strong>不取模</strong>，$\color{red}{100 \rightarrow 10}$ 恐怖。</p><p>$dp$ 真是太好了，样例解释真是太好了。</p><h3 id="题意"><strong>题意</strong></h3><p>求长度为 $n$ 的序列。</p><ul><li>序列中的元素 $0\le a_i\le m$。</li><li>序列 ${a_i}$ 满足整数 $S = 2^{a_1} + 2^{a_2} + \cdots + 2^{a_n}$ 的二进制表示中 $1$ 的个数不超过 $k$。</li></ul><p>求贡献总和，贡献为 $v_{a_1} \times v_{a_2} \times \cdots \times v_{a_n}$。</p><p><strong>这个样例解释挺好的</strong>，理解了就会做正解了。</p><blockquote><p>由于 $k = 1$，而且由 $n \leq S \leq n \times 2^m$ 知道 $5 \leq S \leq 10$，合法的 $S$ 只有一种可能：$S = 8$，这要求 $a$ 中必须有 $2$ 个 $0$ 和 $3$ 个 $1$，于是有 $\binom{5}{2} = 10$ 种可能的序列，每种序列的贡献都是 $v_0^2 v_1^3 = 4$，权值和为 $10 \times 4 = 40$。</p></blockquote><p>保证 $1 \leq k \leq n \leq 30$，$0 \leq m \leq 100$，$1\le v_i \le 998244353$。</p><ul><li>爆搜 $O(m^n)$，$\color{red}{20pts}$</li><li>记忆化，记录到第 $i$ 位权值为 $x$ 的贡献，$f_{i,x}$，复杂度 $O(n\times n\times 2^m \times m)$，<strong>根据记忆化数组大小以及计算贡献复杂度求复杂度</strong>，$\color{red}{50pts}$</li><li>$dp$，$\color{red}{100pts}$</li></ul><p><strong>通过发现最后的答案序列不就是多个二进制相加吗</strong>。</p><p>考虑设置状态我们发现有 $k$ 的限制这不就启发我们考虑二进制运算，对于 $n$ 个数每个数可以选无限种，但是 $1$ 的个数最多只有 $l$ 个，不同的数之间选多选少肯定是有进位的。</p><p>直接涉及 $f_{i,j,k,l}$ 当前考虑到二进制位 $i$，序列中已经有 $j$ 个数，当前对 $i+1$ 位有 $k$ 的进位，当前序列已经有了 $l$ 个 $1$。</p><p><strong>此处二进制位从 $0$ 开始</strong>。</p><p>从低位到高位无后效性，因此可以转移。</p><p>$$<br>f_{i+1,j+t,\lfloor \frac{t+k}{2} \rfloor,l+(t+k)\operatorname{mod}2 } \leftarrow f_{i,j,k,l} \binom{n-j}{t} v_i^t,0\le t\le m<br>$$</p><p><strong>注</strong>：<strong>对于</strong> $dp$ <strong>初始化考虑实际意义即可</strong>。</p><h3 id="细节："><strong>细节</strong>：</h3><p><strong>到最后可能还有进位那么就需要多考虑以为把进位都加进去</strong>。</p><h3 id="复杂度"><strong>复杂度</strong></h3><p>$O(m\times n^4)\approx 8.1\times 10^7$，可过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)&#123;f=<span class="number">-1</span>;&#125; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">33</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">108</span>;</span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"><span class="type">int</span> pv[M][N];</span><br><span class="line"><span class="type">int</span> dp[M][N][N/<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        pv[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            pv[i][j]=(<span class="number">1ll</span>*pv[i][j<span class="number">-1</span>]*pv[i][<span class="number">1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">popcount</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(val)&#123;</span><br><span class="line">        val-=<span class="built_in">lowbit</span>(val);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,K;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(m),<span class="built_in">read</span>(K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(pv[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>(n,m);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n/<span class="number">2</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=K;l++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=n-j;t++)&#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][j+t][(t+k)/<span class="number">2</span>][l+(t+k)%<span class="number">2</span>]=(dp[i+<span class="number">1</span>][j+t][(t+k)/<span class="number">2</span>][l+(t+k)%<span class="number">2</span>]+<span class="number">1ll</span>*dp[i][j][k][l]*C[n-j][t]%mod*pv[i][t]%mod)%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n/<span class="number">2</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=K;l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l+<span class="built_in">popcount</span>(k)&lt;=K)&#123;</span><br><span class="line">                ans+=dp[m+<span class="number">1</span>][n][k][l];</span><br><span class="line">                ans%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><strong>NOIP 2020</strong></h1><h2 id="移球游戏"><strong>移球游戏</strong></h2><p>在 $820000$ 内次操作将 $n$ 个栈，每个栈有 $m$ 个元素，还原成规则栈。</p><p><strong>限制</strong>：总共有 $n$ 种元素，每种元素有 $m$ 个。</p><p><strong>数据范围</strong>：$n\le 50,2\le m\le400$</p><h3 id="分析"><strong>分析</strong></h3><p>借助样例 $2$，我们模拟一下，考虑还原颜色只用 $3$ 个栈，这样是优秀的，并不会影响别的栈。</p><p>那么 $6$ 种操作结束。</p><p>先设定一种颜色为 $0$，另一种颜色为 $1$，那么可以考虑，最终序列为全 $0$ 栈，全 $1$ 栈，空栈。</p><p>设 $1$ 栈中 $0$ 的个数为 $s$。</p><ul><li>$2$ 栈移走s到 $3$ 栈 $\color{red}{s}$</li><li>$1$ 栈移 $0$ 到 $2$ ，移 $1$ 到 $3$ 栈 $\color{red}{m}$</li><li>移 $2$ 栈全 $0$ 个数 $s$ 到 $1$ ，移 $3$ 栈全 $1$ 个数 $m-s$ 到 $1$ 栈  $\color{red}{m}$</li><li>移 $2$ 栈剩下的 $m-s$ 到 $3$ 栈  $\color{red}{m-s}$</li><li>移 $1$ 栈 $m-s$ 个全 $1$ 到 $2$ 栈 $\color{red}{m-s}$</li><li>移 $3$ 栈为 $0$ 到 $1$ ，移 $3$ 栈全 $1$ 到 $2$ 栈 $\color{red}{m}$</li></ul><p>总计 $5m-s$ 次操作。</p><p>显然这种操作只适用于两栈只有两种相同的颜色，但是对于 $n$ 个栈颜色肯定都是乱序的，<strong>那我们就强行固定一个顺序</strong>，那么考虑<strong>分治</strong>，对于每一个位置代表一种颜色，对于移动的 $s$ 是什么当然肯定就是考虑当前 $\le mid$ 放左，$&gt;mid$ 放右，通过多次当最后相等的时候也就完成了操作，这里有一个优化，因为我们的操作是 $5m-s$，$s$ 与个数有关，那么就考虑选更多的去匹配，我们考虑 $mid$ 左右依次匹配，<strong>细节见下</strong>。</p><p><strong>请注意一个小细节</strong>，<strong>如果是偶数肯定每个都会匹配一次</strong>，<strong>但对于奇数也不慌</strong>，<strong>随着递归奇偶会变化</strong>，<strong>因为我们保证了他是归一方的</strong>。</p><h3 id="细节：-2"><strong>细节</strong>：</h3><ul><li>具体的实现细节，我们可以考虑将栈的转移规定成一个函数，最后好输出操作，<strong>与喵了个喵</strong>相似。</li><li>每次递归下去一定是可以保证栈中元素为 $m$ 的，但是对于连个栈操作的时候可能存在一种元素严格大于另一种，注意别让栈超过 $m$ 即可。</li><li>请注意是从栈顶依次取哦。</li></ul><h3 id="时间复杂度："><strong>时间复杂度</strong>：</h3><p>$$O(5n^2m \log n)=3\times 10^7$$</p><h3 id="操作次数："><strong>操作次数</strong>：</h3><p>$$<br>\begin{aligned}<br>T(n)&amp;=2T(n/2)+5mn\<br>&amp;=5mn\log n\<br>&amp;\approx6\times 10^5 &lt;8.2\times 10^5<br>\end{aligned}<br>$$</p><p><strong>复杂度是是严格可以的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)&#123;f=<span class="number">-1</span>;&#125; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50</span>+<span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">400</span>+<span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">82e4</span>+<span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> a[N][M],top[N],n,m,ans[K][<span class="number">2</span>],tot;</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pour</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    ans[++tot][<span class="number">0</span>]=x,ans[tot][<span class="number">1</span>]=y;</span><br><span class="line">    a[y][++top[y]]=a[x][top[x]--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="keyword">sizeof</span> flag);</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     assert(top[i]==m);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=mid;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=mid+<span class="number">1</span>;j&lt;=r;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]||flag[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line">                s+=(a[i][k]&lt;=mid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line">                s+=(a[j][k]&lt;=mid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//s+m+s+(m-s)+(m-s)+(m-s)+m=5m-s</span></span><br><span class="line">            <span class="keyword">if</span>(s&gt;=m)&#123;</span><br><span class="line">                s=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line">                    s+=(a[i][k]&lt;=mid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s;k++)&#123;</span><br><span class="line">                    <span class="built_in">pour</span>(j,n+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//m</span></span><br><span class="line">                <span class="comment">//请注意是从栈顶依次取哦</span></span><br><span class="line">                <span class="keyword">while</span>(top[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][top[i]]&lt;=mid)&#123;</span><br><span class="line">                        <span class="built_in">pour</span>(i,j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">pour</span>(i,n+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s;k++)&#123;</span><br><span class="line">                    <span class="built_in">pour</span>(j,i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//m-s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m-s;k++)&#123;</span><br><span class="line">                    <span class="built_in">pour</span>(n+<span class="number">1</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//m-s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m-s;k++)&#123;</span><br><span class="line">                    <span class="built_in">pour</span>(j,n+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//m-s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m-s;k++)&#123;</span><br><span class="line">                    <span class="built_in">pour</span>(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//m</span></span><br><span class="line">                <span class="comment">//这就是一种元素严格大于另一种不能爆栈</span></span><br><span class="line">                <span class="keyword">while</span>(top[n+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(top[i]==m||a[n+<span class="number">1</span>][top[n+<span class="number">1</span>]]&gt;mid) <span class="built_in">pour</span>(n+<span class="number">1</span>,j);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">pour</span>(n+<span class="number">1</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">                flag[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line">                    s+=(a[j][k]&gt;mid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s;k++)&#123;</span><br><span class="line">                    <span class="built_in">pour</span>(i,n+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//m</span></span><br><span class="line">                <span class="keyword">while</span>(top[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j][top[j]]&gt;mid)&#123;</span><br><span class="line">                        <span class="built_in">pour</span>(j,i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">pour</span>(j,n+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s;k++)&#123;</span><br><span class="line">                    <span class="built_in">pour</span>(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//m-s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m-s;k++)&#123;</span><br><span class="line">                    <span class="built_in">pour</span>(n+<span class="number">1</span>,j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//m-s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m-s;k++)&#123;</span><br><span class="line">                    <span class="built_in">pour</span>(i,n+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//m-s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m-s;k++)&#123;</span><br><span class="line">                    <span class="built_in">pour</span>(j,i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//m</span></span><br><span class="line">                <span class="keyword">while</span>(top[n+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(top[j]==m||a[n+<span class="number">1</span>][top[n+<span class="number">1</span>]]&lt;=mid) <span class="built_in">pour</span>(n+<span class="number">1</span>,i);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">pour</span>(n+<span class="number">1</span>,j);</span><br><span class="line">                &#125;</span><br><span class="line">                flag[j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(l,mid);</span><br><span class="line">    <span class="built_in">solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;D:\\newfile\\in\\ball3.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;ball.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            a[i][++top[i]]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">write</span>(tot);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="built_in">write</span>(ans[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><strong>NOIP 2018</strong></h1><h2 id="赛道修建"><strong>赛道修建</strong></h2><p>考虑每个节点的子树对该节点的贡献，选择最大的去贡献就好。</p><p>$O(n \log n^2)$</p><h2 id="保卫王国"><strong>保卫王国</strong></h2><p>无修改操作的树上问题考虑倍增，并且一条边至少选择一个节点，显然考虑 $dp$。</p><p>设 $f_{i,0/1}$ 以 $i$ 为根的子树，当前选择或不选择这个根节点 $i$ 的最小代价。</p><p>$g_{i,0/1}$ 除去以 $i$ 为根的子树（包含 $i$ 节点），当前选择或不选择这个根节点 $i$ 的最小代价。</p><p>$dp_{i,j,0/1,0/1}$ 以 $i$ 为起点，状态为 $k$，跳到 $2^j$ 的父亲，父亲状态为 $l$ 的这段 $(i,i+2^j]$（即不含 $i$ 节点）区间的最小代价。</p><p>显然 $\min(f_{i,0}+g_{i,0},f_{i,1}+g_{i,1})$ 就是全局无限制的答案。</p><p>有限制就倍增就好。</p><p>时间复杂度为 $O((n+q)\log n$。</p><hr><p>附上转移方程。</p><p>若选 $u$，$v$ 可选可不选。<br>不选 $u$，$v$ 必选。<br>$$<br>f_{u,0}=\sum_{v\in u}f_{v,1}\<br>f_{u,1}=\sum_{v\in u}\min(f_{v,1},f_{v,0})<br>$$<br>容斥即可。<br>$$<br>g_{v,0}=g_{u,1}+f_{u,1}-\min(f_{v,0}+f_{v,1})\<br>g_{v,1}=\min(g_{u,0}+f_{u,0}-f_{v,1},g_{u,1}+f_{u,1}-\min(f_{v,0}+f_{v,1}))\<br>$$</p><p>倍增预处理过于简单，就是从小的向大的更新。</p><p>处理答案从大的向小的更新，倍增时记录一下最优的答案，一直跳父亲就行，知道跳到一个父亲，因此有在一条链和不是的两种情况，就是类似于倍增求 $LCA$。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;T f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)&#123;f=<span class="number">-1</span>;&#125;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1E5</span>+<span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=N*<span class="number">2</span>;</span><br><span class="line"><span class="comment">//2^17=131072&gt;1E5</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> g[N][<span class="number">2</span>],f[N][<span class="number">2</span>],dp[N][<span class="number">18</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> n,q,val[N];</span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; st;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> father[N][<span class="number">18</span>];</span><br><span class="line"><span class="type">int</span> dep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_f</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>]=val[u];</span><br><span class="line">    father[u][<span class="number">0</span>]=fa;</span><br><span class="line">    dep[u]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs_f</span>(v,u);</span><br><span class="line">        f[u][<span class="number">1</span>]+=<span class="built_in">min</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">        f[u][<span class="number">0</span>]+=f[v][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        g[v][<span class="number">0</span>]=g[u][<span class="number">1</span>]+f[u][<span class="number">1</span>]-<span class="built_in">min</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">        g[v][<span class="number">1</span>]=<span class="built_in">min</span>(g[u][<span class="number">0</span>]+f[u][<span class="number">0</span>]-f[v][<span class="number">1</span>],g[v][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">dfs_g</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> a,<span class="type">int</span> y,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y),<span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="comment">//确定住</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tx[<span class="number">2</span>],ty[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">memset</span>(tx,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> tx);</span><br><span class="line">    <span class="built_in">memset</span>(ty,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> ty);</span><br><span class="line">    <span class="comment">//中转</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> nx[<span class="number">2</span>],ny[<span class="number">2</span>];</span><br><span class="line">    tx[a]=f[x][a];</span><br><span class="line">    ty[b]=f[y][b];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">17</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[father[x][i]]&gt;=dep[y])&#123;</span><br><span class="line">            nx[<span class="number">0</span>]=nx[<span class="number">1</span>]=<span class="number">1e17</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">                    nx[j]=<span class="built_in">min</span>(nx[j],tx[k]+dp[x][i][k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tx[<span class="number">0</span>]=nx[<span class="number">0</span>],tx[<span class="number">1</span>]=nx[<span class="number">1</span>],x=father[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">        <span class="keyword">return</span> tx[b]+g[y][b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">17</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(father[x][i]!=father[y][i])&#123;</span><br><span class="line">            ny[<span class="number">0</span>]=ny[<span class="number">1</span>]=nx[<span class="number">0</span>]=nx[<span class="number">1</span>]=<span class="number">1e17</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">                    nx[j]=<span class="built_in">min</span>(nx[j],tx[k]+dp[x][i][k][j]);</span><br><span class="line">                    ny[j]=<span class="built_in">min</span>(ny[j],ty[k]+dp[y][i][k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tx[<span class="number">0</span>]=nx[<span class="number">0</span>],tx[<span class="number">1</span>]=nx[<span class="number">1</span>],x=father[x][i];</span><br><span class="line">            ty[<span class="number">0</span>]=ny[<span class="number">0</span>],ty[<span class="number">1</span>]=ny[<span class="number">1</span>],y=father[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lca=father[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(f[lca][<span class="number">0</span>]+g[lca][<span class="number">0</span>]-f[x][<span class="number">1</span>]-f[y][<span class="number">1</span>]+tx[<span class="number">1</span>]+ty[<span class="number">1</span>],</span><br><span class="line">    f[lca][<span class="number">1</span>]+g[lca][<span class="number">1</span>]-<span class="built_in">min</span>(f[x][<span class="number">0</span>],f[x][<span class="number">1</span>])-<span class="built_in">min</span>(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>])+<span class="built_in">min</span>(tx[<span class="number">0</span>],tx[<span class="number">1</span>])+<span class="built_in">min</span>(ty[<span class="number">0</span>],ty[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(q);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u),<span class="built_in">read</span>(v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">        st.<span class="built_in">insert</span>(&#123;u,v&#125;),st.<span class="built_in">insert</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs_f</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//f包含本身</span></span><br><span class="line">    <span class="built_in">dfs_g</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//g是出去本身</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1e17</span>;</span><br><span class="line">        <span class="comment">//下面是开区间，上面是闭区间</span></span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=f[father[i][<span class="number">0</span>]][<span class="number">1</span>]-<span class="built_in">min</span>(f[i][<span class="number">0</span>],f[i][<span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=f[father[i][<span class="number">0</span>]][<span class="number">0</span>]-f[i][<span class="number">1</span>];</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=f[father[i][<span class="number">0</span>]][<span class="number">1</span>]-<span class="built_in">min</span>(f[i][<span class="number">0</span>],f[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">17</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            father[j][i]=father[father[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;<span class="number">2</span>;l++)&#123;</span><br><span class="line">                    dp[j][i][k][l]=<span class="number">1e17</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>;m&lt;<span class="number">2</span>;m++)&#123;</span><br><span class="line">                        dp[j][i][k][l]=<span class="built_in">min</span>(dp[father[j][i<span class="number">-1</span>]][i<span class="number">-1</span>][m][l]+dp[j][i<span class="number">-1</span>][k][m],dp[j][i][k][l]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,x,y;</span><br><span class="line">        <span class="built_in">read</span>(a),<span class="built_in">read</span>(x),<span class="built_in">read</span>(b),<span class="built_in">read</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(!x&amp;&amp;!y&amp;&amp;st.<span class="built_in">find</span>(&#123;a,b&#125;)!=st.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(<span class="built_in">solve</span>(a,x,b,y)),<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><strong>NOIP 2017</strong></h1><h2 id="列队">列队</h2><p><a href="https://www.cnblogs.com/LawrenceSivan/p/14686207.html#">参考博客</a> 这是一篇讲具体操作的博客。</p><p>不会平衡树，但会主席树，因此用线段树来做。</p><p>考虑每次修改真正会移动的点只有 $((n+m-1)\times q)$，每次也就相当于删去一个点，然后再末尾添加一个点。</p><p>那么由于空间限制我们使用动态开点线段树空间复杂度 $q\log n$。</p><p>考虑前 $n$ 行的 $[1,m-1]$，和第 $m$ 列建立 $n+1$ 颗线段树。</p><p>每次操作相当于。</p><ul><li>删去一个点</li><li>末尾添加一个点</li><li>查询第 $k$ 小的点</li></ul><p>显然这是可做的。</p><p>时间复杂度 $q \log n$</p><p>代码实现难度不高，<strong>主要是考虑在原区间上加点建立新节点的操作，以及每次操作求值，因为没被开过的点一定是原来的定点；还有就是对于未开的点我们每次可以求出这个区间有多少个数，以及我们对于还未添加的区间虽然已经保留了值域，但是绝对不能添加信息，因为这是不只有在添加时我们增加 $1$ 即可</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)&#123;f=<span class="number">-1</span>;&#125; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> sz;</span><br><span class="line">    <span class="type">int</span> ls,rs;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="comment">//q log n 2^32保证</span></span><br><span class="line"><span class="type">int</span> n,m,q,x,y;</span><br><span class="line"><span class="type">int</span> now;<span class="comment">//现在需要操作的是那一颗线段树</span></span><br><span class="line"><span class="type">int</span> rt[N+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> ins[N+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEGEMENTTREE</span>&#123;</span><br><span class="line">    <span class="comment">//不动的点是时候加进来了</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">len</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now==n+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r&lt;=n) <span class="keyword">return</span> (r-l+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l&lt;=n) <span class="built_in">return</span> (n-l+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(r&lt;=m<span class="number">-1</span>) <span class="built_in">return</span> (r-l+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l&lt;=m<span class="number">-1</span>) <span class="built_in">return</span> (m<span class="number">-1</span>-l+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入查询出来的新人到末尾</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">long</span> <span class="type">long</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u)&#123;</span><br><span class="line">            u=++cnt;</span><br><span class="line">            tr[u].sz=<span class="built_in">len</span>(l,r);    </span><br><span class="line">            <span class="keyword">if</span>(l==r) tr[u].val=num;</span><br><span class="line">        &#125;</span><br><span class="line">        tr[u].sz++;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid) <span class="built_in">modify</span>(tr[u].ls,l,mid,pos,num);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(tr[u].rs,mid+<span class="number">1</span>,r,pos,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u)&#123;</span><br><span class="line">            u=++cnt;</span><br><span class="line">            tr[u].sz=<span class="built_in">len</span>(l,r);</span><br><span class="line">            <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(now==n+<span class="number">1</span>) tr[u].val=(<span class="number">1ll</span>*l*m);</span><br><span class="line">                <span class="keyword">else</span> tr[u].val=(<span class="number">1ll</span>*(now<span class="number">-1</span>)*m)+l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查询到就意味着删除，即保证每个点都是有值的</span></span><br><span class="line">        tr[u].sz--;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[u].val;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//pos与线段树实际下标无关只与类似于主席树查询k小有关</span></span><br><span class="line">        <span class="keyword">if</span>((!tr[u].ls&amp;&amp;<span class="built_in">len</span>(l,mid)&gt;=pos)||(tr[tr[u].ls].sz&gt;=pos))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(tr[u].ls,l,mid,pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            <span class="keyword">if</span>(!tr[u].ls) tmp=<span class="built_in">len</span>(l,mid);</span><br><span class="line">            <span class="keyword">else</span> tmp=tr[tr[u].ls].sz;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(tr[u].rs,mid+<span class="number">1</span>,r,pos-tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="type">int</span> range;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(m),<span class="built_in">read</span>(q);</span><br><span class="line">    range=<span class="built_in">max</span>(n,m)+q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x),<span class="built_in">read</span>(y);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(y==m)&#123;</span><br><span class="line">            now=n+<span class="number">1</span>;</span><br><span class="line">            ans=T.<span class="built_in">query</span>(rt[now],<span class="number">1</span>,range,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            now=x;</span><br><span class="line">            ans=T.<span class="built_in">query</span>(rt[now],<span class="number">1</span>,range,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(ans),<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        now=n+<span class="number">1</span>;</span><br><span class="line">        T.<span class="built_in">modify</span>(rt[now],<span class="number">1</span>,range,n+(++ins[now]),ans);</span><br><span class="line">        <span class="keyword">if</span>(y!=m)&#123;</span><br><span class="line">            ans=T.<span class="built_in">query</span>(rt[now],<span class="number">1</span>,range,x);</span><br><span class="line">            now=x;</span><br><span class="line">            T.<span class="built_in">modify</span>(rt[now],<span class="number">1</span>,range,m<span class="number">-1</span>+(++ins[now]),ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小凯的疑惑">小凯的疑惑</h2><p>结论：$a,b$ 可以表示 $&gt;a\times b-a-b,gcd(a,b)=1$</p><h1><strong>NOIP 2016</strong></h1><h1>换教室</h1><p>跟据期望线性性即可。</p><p>设 $f_{i,j,0/1}$ 表示前 $i$ 个考虑完，当前用几个，当前这位的状态是什么。</p><p>转移式就是将所有情况加起来，太长了懒了。</p><p><a href="https://oi-wiki.org/math/probability/exp-var/">关于期望</a></p>]]></content>
    
    
    <summary type="html">NOIP整理</summary>
    
    
    
    <category term="CCF" scheme="https://uicere.github.io/category/CCF/"/>
    
    
    <category term="真题总结" scheme="https://uicere.github.io/tag/%E7%9C%9F%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>P7468 [NOI Online 2021 提高组] 愤怒的小 N</title>
    <link href="https://uicere.github.io/article/10/"/>
    <id>https://uicere.github.io/article/10/</id>
    <published>2023-08-29T16:00:00.000Z</published>
    <updated>2023-08-31T01:59:05.467Z</updated>
    
    <content type="html"><![CDATA[<p>设：<br>$$<br>S_i(n)=\sum_{j=0}^{n-1}j^i<br>$$<br>对 $S_{i+1}(n)$ 使用扰动法，<br>$$<br>S_{i+1}(n)=\sum_{j=0}^{n-1}j^{i+1}\<br>=\sum_{j=0}^{n}j^{i+1}-n^{i+1}\<br>=\sum_{j=1}^nj^{i+1}-n^{i+1}\<br>=\sum_{j=0}^{n-1}(j+1)^{i+1}-n^{i+1}\<br>=\sum_{j=0}^{n-1}(j+1)^{i+1}-n^{i+1}\<br>=\sum_{j=0}^{n-1}\sum_{c=0}^{i+1}\binom{i+1}{c}j^c-n^{i+1}\<br>=\sum_{c=0}^{i+1}\binom{i+1}{c}S_c(n)-n^{i+1}\<br>=S_{i+1}(n)+(i+1)S_i(n)+\sum_{c=0}^{i-1}\binom{i+1}{c}S_c(n)-n^{i+1}<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设：&lt;br&gt;
$$&lt;br&gt;
S_i(n)=&#92;sum_{j=0}^{n-1}j^i&lt;br&gt;
$$&lt;br&gt;
对 $S_{i+1}(n)$ 使用扰动法，&lt;br&gt;
$$&lt;br&gt;
S_{i+1}(n)=&#92;sum_{j=0}^{n-1}j^{i+1}&#92;&lt;br&gt;
=&#92;sum_{j=0}^</summary>
      
    
    
    
    
    <category term="真题" scheme="https://uicere.github.io/tag/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>noi-online2022</title>
    <link href="https://uicere.github.io/article/8/"/>
    <id>https://uicere.github.io/article/8/</id>
    <published>2023-08-29T16:00:00.000Z</published>
    <updated>2023-08-31T01:58:59.600Z</updated>
    
    <content type="html"><![CDATA[<h1>丹钓战</h1><h2 id="倍增">倍增</h2><p>给定一个很具体的操作，显然每次都是再重复计算，直接考虑倍增，从每个点出发第一个<strong>被成功的</strong>弹出，那个点所在的位置，倍增维护。</p><p>$O(n\log n)$</p><p>像这种重复操作的倍增，基本就是维护的是走多少合法得步数，可以走到得位置是什么。</p><p>又根据任意一个正整数都可以表示为二进制拆分，所以操作可行。</p><h2 id="树状数组">树状数组</h2><p>$O(n\log n)$</p><p><a href="https://www.luogu.com.cn/blog/380019/solution-p8251">zero</a></p><h2 id="莫队">莫队</h2><p>$O(n \sqrt[2]{n})$</p><p><a href="https://www.luogu.com.cn/blog/483037/solution-p8251">zero</a></p><h1>讨论</h1><p><img src="image.png" alt="Alt text"></p><p>直接考虑拥有同一元素的相邻两个集合快速判断包含性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;T f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)&#123;f=<span class="number">-1</span>;&#125;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1E6</span>+<span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"><span class="type">int</span> k[N],a[N];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; p[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> k[x]&lt;k[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;discuss2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;discuss.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line"><span class="built_in">read</span>(n);</span><br><span class="line">for_each(p,p+N,[](vector&lt;<span class="type">int</span>&gt;&amp; v)&#123;v.<span class="built_in">clear</span>();&#125;);</span><br><span class="line">p-&gt;<span class="built_in">shrink_to_fit</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">read</span>(k[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;k[i];++u)&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">read</span>(x);</span><br><span class="line">p[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;  </span><br><span class="line">a[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n&amp;&amp;!flag;t++)&#123;</span><br><span class="line"><span class="type">int</span> i=a[t];</span><br><span class="line"><span class="keyword">if</span>(k[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(t^<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;k[i];u++)&#123;</span><br><span class="line">    ++cnt[vis[p[i][u]]];</span><br><span class="line">    &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;k[i];u++)&#123;</span><br><span class="line">        <span class="type">int</span> g=vis[p[i][u]];</span><br><span class="line">        <span class="keyword">if</span>(cnt[g]&lt;k[g]&amp;&amp;cnt[g]&lt;k[i])&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="built_in">write</span>(i); <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>); <span class="built_in">write</span>(g); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;k[i];u++)&#123;</span><br><span class="line">        --cnt[vis[p[i][u]]];</span><br><span class="line">        vis[p[i][u]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;k[i];u++)&#123;</span><br><span class="line">        vis[p[i][u]]=i;</span><br><span class="line">        &#125; </span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag)<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;丹钓战&lt;/h1&gt;
&lt;h2 id=&quot;倍增&quot;&gt;倍增&lt;/h2&gt;
&lt;p&gt;给定一个很具体的操作，显然每次都是再重复计算，直接考虑倍增，从每个点出发第一个&lt;strong&gt;被成功的&lt;/strong&gt;弹出，那个点所在的位置，倍增维护。&lt;/p&gt;
&lt;p&gt;$O(n&#92;log n)$&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="真题" scheme="https://uicere.github.io/tag/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
</feed>
